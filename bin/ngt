#!/usr/bin/env perl

#*******************************************************************************
##                           COPYRIGHT NOTICE
##      (c) 2019 The Johns Hopkins University Applied Physics Laboratory
##                         All rights reserved.
##
##  Permission is hereby granted, free of charge, to any person obtaining a 
##  copy of this software and associated documentation files (the "Software"), 
##  to deal in the Software without restriction, including without limitation 
##  the rights to use, copy, modify, merge, publish, distribute, sublicense, 
##  and/or sell copies of the Software, and to permit persons to whom the 
##  Software is furnished to do so, subject to the following conditions:
## 
##     The above copyright notice and this permission notice shall be included 
##     in all copies or substantial portions of the Software.
##
##  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
##  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
##  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL 
##  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
##  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 
##  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER 
##  DEALINGS IN THE SOFTWARE.
##
#*******************************************************************************/

# ngt - The shorter version of nuggit

# Optional Dependencies:
#   Complete::Program - to enable auto-completion of programs

use strict;
use warnings;
use v5.10; # Adds say function
use FindBin;
use Term::ANSIColor;

# Get First Parameter (case-insensitive)
my $cmd = lc(shift) if @ARGV;

# Command Database (excludes help/doc/env commands defined in this file)
my %files =
(
 # Core Commands
 add    => {cmd => "nuggit_add.pl",
            completion_type => "file"},
 branch => "nuggit_branch.pl",
 checkout => "nuggit_checkout.pl", # TODO: Autocomplete known (root-level) branches
 checkout_default => {cmd => "nuggit_checkout_default.pl",
                      description => "Checkout default/tracked branch for each submodule"
                     },
 clone     => "nuggit_clone.pl",
 commit    => "nuggit_commit.pl",
 diff      => {cmd => "nuggit_diff.pl", completion_type => "file"},
 difftool  =>  {cmd => "nuggit_foreach.pl", args => [ qw( --log_level 0 git difftool) ] },
 fetch     => "nuggit_fetch.pl",
 init      => "nuggit_init.pl",
 log       => "nuggit_log.pl",
 merge     => "nuggit_merge.pl",
 mergetool => {cmd => "nuggit_foreach.pl", args => [ qw( git mergetool) ] },
 mv        => {cmd => "nuggit_mv.pl", completion_type => "file"},
 pull      => "nuggit_pull.pl",
 push      => "nuggit_push.pl",
 remote    => "nuggit_remote.pl",
 reset     => {cmd => "nuggit_reset.pl", completion_type => "file"},
 rm        => {cmd => "nuggit_rm.pl", completion_type => "file"},
 stash     => {cmd => "nuggit_foreach.pl", args => [ qw( git stash) ],
             completion_list => [qw(save pop list show drop apply branch)]
            },
 status     => {cmd => "nuggit_status.pl", completion_type => "file"},
 tag        => {cmd => "nuggit_foreach.pl", args => [ qw( --no-break-on-error git tag )]},
 
 # For Advanced Users
 foreach => {cmd => "nuggit_foreach.pl",
             completion_type => "system" # Use system default completion
            },
 
);

# Supported Autocompletion Shells:
#Complete::Bash - provides COMP_LINE and COMP_POINT
# Complete::Zsh - ?
# Complete::Tcsh - provides COMMAND_LINE env variable
if (defined($ENV{'COMP_LINE'}) || defined($ENV{'COMMAND_LINE'}) ) {
    require Complete::File;
    Complete::File->import('complete_file');
    require Complete::Util;
    Complete::Util->import('complete_array_elem');

    if (defined($ENV{'COMP_LINE'})) {
        require Complete::Bash;
        Complete::Bash->import(qw(parse_cmdline format_completion));
    } elsif (defined($ENV{'COMMAND_LINE'}) ) {
        require Complete::Tcsh;
        Complete::Tcsh->import(qw(parse_cmdline format_completion));
    }

    my( $words, $cword) = @{ parse_cmdline() };
    my $res;
    my $word = $words->[$cword];
    my $def = $files{$words->[1]};
    if ($cword == 1) {
        $res = complete_array_elem(array=>[keys(%files)], word=>$word);
    } elsif (ref($def)) {
        # Definition available for this command
        if (defined($def->{completion_type}) && $def->{completion_type} eq "file") {
            $res = file_complete($word);
        } elsif (defined($def->{completion_type}) && $def->{completion_type} eq "system") {
            eval {require Complete::Program; } || exit;
            Complete::Program->import('complete_program');
            $res = complete_program(word => $word);
        } elsif (defined($def->{completion_list})) {
            $res = complete_array_elem(array => $def->{completion_list},
                                       word => $word);
        }
    } else {
        # No more auto-completion
        exit;
    }
    print format_completion($res);
    exit;

} elsif (defined($cmd) && $cmd eq "check") {
    # Check for Nuggit Library
    eval "use Git::Nuggit::Status";
    die "Git::Nuggit::Status does not appear to be installed. Did you source nuggit.sh or equivalent?" if $@;

    eval "use Git::Nuggit";
    die "Git::Nuggit does not appear to be installed. Did you source nuggit.sh or equivalent?" if $@;
    
    eval "use IPC::Run3";
    die "IPC::Run3 does not appear to be installed. Install via cpan, or see README for other options." if $@;

    my $git_version = `git --version`;
    if ($git_version =~ /git version (\d)\.(\d+)\.?(\d+)?/) {
        die "Warning: Git 2.13.2 or later is required for full functionality." unless ( ($1 >= 2 && $2 > 13) || ($1 == 2 && $2 == 13 && 3 >= 2));
    } else {
        die "Unable to find git";
    }

    #say "Using Git::Nuggit version " . $Git::Nuggit::VERSION; # Git::Nuggit not fully defined as package
    say "Using Git::Nuggit::Status version " . $Git::Nuggit::Status::VERSION;

    say "All compatibility checks have passed";

    my ($root_dir, $relative_path_to_root) = find_root_dir();
    if ($root_dir) {
        say "Nuggit Root Directory located at $root_dir  (aka $relative_path_to_root)";
    } else {
        say "Not current in a Nuggit workspace.";
    }
    
    exit;
} elsif (defined($cmd) && $cmd =~ /(help|man)$/) {
    show_help();
} elsif (defined($cmd) && $cmd eq "generatedocs") {
    generate_help();
} elsif (defined($cmd) && defined($files{$cmd})) {
    # Execute specified file directly
    my $rawcmd = $FindBin::Bin.'/';
    my $obj = $files{$cmd};

    if (ref($obj)) {
        if ($obj->{'args'}) {
            my @tmp = @{$obj->{'args'}};
            push(@tmp, @ARGV);
            @ARGV = @tmp;
        }
        $rawcmd .= $obj->{'cmd'};
    } else {
        $rawcmd .= $obj;
    }

    unshift(@ARGV, $rawcmd);
    exec(@ARGV);
    exit;
} elsif (defined($cmd)) {
  say "ERROR: Unrecognized Command ($cmd)";
} else {
    say colored("Please specify a valid command", 'red');
    show_help();
}

sub show_help {
    say "---------------------------------------------------";
    say "Nuggit; A Git Utility for Submodule-based workflows";
    say "---------------------------------------------------";
    say "Usage: ngt <cmd> <args>\n";

    say "This is a wrapper for available nuggit commands. Internal commands are:";
    say "  ngt help      Show this help dialog";
    say "  ngt check     Verify nuggit installation and dependencies\n";

    say "Commands for 'ngt' can be autocompleted by pressing the tab key, while a list";
    say "  of all matches can be returned by pressing tab twice. This will work";
    say "  on Bash and CSH terminals only, providing that the nuggit.[c]sh script";
    say "  has been sourced.\n";
    
    say "Most of the commands below have their own help page";
    say " accessible as 'ngt <cmd> --help' for abbreviated usage";
    say " or 'ngt <cmd> --man' for detailed usage information.";
    say "\n";
    
    foreach my $file (sort keys %files) {
        my $obj = $files{$file};
        print " ".$file." ";
        if (ref($obj)) {
            if ($obj->{'completion_list'}) {
                my $first = 0;
                foreach my $subcmd (@{$obj->{'completion_list'}}) {
                    print "|" unless !$first;
                    print $subcmd;
                    $first++;
                }
            } elsif (defined($obj->{'completion_type'})) {
                if ($obj->{'completion_type'} eq "file") {
                    print "<file>";
                }
            }
            print "\t".$obj->{'description'} if defined($obj->{'description'});
        }
        print "\n";
    }
}

sub generate_help {
    # Conditionally include (so we don't break other functions if not available)
    eval "use Pod::Simple::HTMLBatch"; die $@ if $@;
    eval "use Pod::Simple::XHTML"; die $@ if $@;
    use List::Util qw(first);

    mkdir './html';

    my $convert = Pod::Simple::HTMLBatch->new;
    $convert->html_render_class('Pod::Simple::XHTML');
    $convert->add_css('http://www.perl.org/css/perl.css');
    $convert->css_flurry(1);
    $convert->javascript_flurry(1);
    $convert->contents_file(1);    
    $convert->batch_convert(['./pod','./bin','./lib/Git'], './html');

    # Open Directory and get list of generated HTML files.
    chdir('html');
    my @htmlfiles = glob( '*.html */*.html');

    open(my $idx, '>', "index.html") || die("Can't create index.html");
    say $idx "<HTML><HEAD><TITLE>Nuggit Help</TITLE></HEAD><BODY>";
    say $idx "<H1>Nuggit; A Git Utility for submodule-based workflows</H1>";
    say $idx <<EOF;

    <p><b>Usage:</b> ngt <cmd> <args></p>

    <p>"ngt" is a wrapper for available nuggit commands.  Use "ngt help" to list a version of this help page, or "ngt check" to verify your installation.  "ngt generatedocs" can be used to generate this documentation.</p>

    <p>Commands for 'ngt' can be autocompleted by pressing the tab key, while a list
  of all matches can be returned by pressing tab twice. This will work
  on Bash and CSH terminals only, providing that the nuggit.[c]sh script
  has been sourced.</p>

  <p>Most of the commands below have their own help page accessible
 from the command line as 'ngt <cmd> --help' for abbreviated usage or
 'ngt <cmd> --man' for detailed usage information, with HTML versions
 linked below.</p>


EOF

    say $idx "<h2>Commands:</h2><ul>";
    foreach my $file (sort keys %files) {
        my $obj = $files{$file};
        print $idx "<li><p>";

        # If a matching HTML file exists, link to it.
        my $index = first { $htmlfiles[$_] eq "nuggit_$file.html" } 0..$#htmlfiles;
        #my $index = first { $_ eq "nuggit_$file.html" } @htmlfiles;
        if (defined($index)) {
            print $idx "<a href=".$htmlfiles[$index].">$file</a> ";
            splice(@htmlfiles, $index, 1);
        } else {
            print $idx $file." ";
        }
        
        if (ref($obj)) {
            if ($obj->{'completion_list'}) {
                my $first = 0;
                foreach my $subcmd (@{$obj->{'completion_list'}}) {
                    print $idx "|" unless !$first;
                    print $idx $subcmd;
                    $first++;
                }
            } elsif (defined($obj->{'completion_type'})) {
                if ($obj->{'completion_type'} eq "file") {
                    print $idx "<file>";
                }
            }
            print $idx "&mdash;".$obj->{'description'} if defined($obj->{'description'});
        }
        say $idx "</p></li>";
    }
    say $idx "</ul>";
        
    say $idx "<h2>Other Documentation:</h2><ul>";
    foreach my $file (@htmlfiles) {
        say $idx "<li><a href=\"$file\">$file</a></li>";
    }
    say $idx "</ul>";
 
    say $idx "</BODY>";
    
    
    close($idx);
    say "Help Pages have been generated";
}

sub file_complete {
    my $word = shift;
    my $rtv;

    for(my $i = 0; $i < 10; $i++) { # Prevent infinite recursion
        $rtv = complete_file(word => $word,
                             file_regex_filter => qr/^\./  # Hide hidden folders
                            );

        # Continue the loop if sole-completion is a directory
        $word = @{$rtv}[0];
        last unless (@{$rtv}==1 && -d $word);
    }
    return $rtv;
}
